// Copyright 2024 ihciah. All Rights Reserved.

use std::io::Cursor;

use clap::Parser;
use itertools::Itertools as _;
use rust2go_common::common::RawRsFile;

#[derive(Parser, Debug, Default, Clone)]
#[command(author, version, about, long_about = None)]
pub struct Args {
    /// Path of source rust file
    #[arg(short, long)]
    pub src: String,

    /// Path of destination go file
    #[arg(short, long)]
    pub dst: String,

    /// With or without go main function
    #[arg(long, default_value = "false")]
    pub without_main: bool,

    /// Go 1.18 compatible
    #[arg(long, default_value = "false")]
    pub go118: bool,

    /// Disable auto format go file
    #[arg(long, default_value = "false")]
    pub no_fmt: bool,
}

pub fn generate(args: &Args) {
    // Read and parse rs file.
    let file_content = std::fs::read_to_string(&args.src).expect("Unable to read file");
    let raw_file = RawRsFile::new(file_content);

    // Convert to Ref structs and write to output file.
    let (name_mapping, ref_content) = raw_file
        .convert_structs_to_ref()
        .expect("Unable to convert to ref");
    std::fs::write(&args.dst, ref_content.to_string()).expect("Unable to write file");

    // Convert output file with cbindgen.
    let mut cbuilder = cbindgen::Builder::new()
        .with_language(cbindgen::Language::C)
        .with_src(&args.dst)
        .with_header("// Generated by rust2go. Please DO NOT edit this C part manually.");
    for name in name_mapping.values().map(|n| n.to_string()).sorted() {
        cbuilder = cbuilder.include_item(name);
    }
    let mut output = Vec::<u8>::new();
    cbuilder
        .generate()
        .expect("Unable to generate bindings")
        .write(Cursor::new(&mut output));

    // Convert headers into golang.
    let mut importc = String::from_utf8(output).expect("Unable to convert to string");

    let r2g_traits = raw_file.convert_r2g_trait().unwrap();
    let g2r_traits = raw_file.convert_g2r_trait().unwrap();
    macro_rules! r2g_any {
        ($f: expr) => {
            r2g_traits.iter().any(|t| t.fns().iter().any($f))
        };
    }
    macro_rules! g2r_any {
        ($f: expr) => {
            g2r_traits.iter().any(|t| t.fns().iter().any($f))
        };
    }
    macro_rules! or_empty {
        ($flag: expr, $content: expr) => {
            if $flag {
                $content
            } else {
                ""
            }
        };
    }
    let use_shm = r2g_any!(|f| f.mem_call_id().is_some());
    let use_runtime =
        r2g_any!(|f| f.mem_call_id().is_none()) || g2r_traits.iter().any(|t| !t.fns().is_empty());
    let use_cgocall =
        r2g_any!(|f| f.mem_call_id().is_none() && f.cgo_callback()) || g2r_any!(|f| f.cgo_call());
    let use_asmcall =
        r2g_any!(|f| f.mem_call_id().is_none() && !f.cgo_callback()) || g2r_any!(|f| !f.cgo_call());
    if use_shm {
        importc.push_str(RawRsFile::go_shm_include());
    }
    if g2r_traits.iter().any(|t| t.has_ret()) {
        importc.push_str(RawRsFile::go_internal_drop());
    }
    g2r_traits.iter().for_each(|t| {
        importc.push_str(&t.to_importc());
    });

    let import_shm = or_empty!(
        use_shm,
        "mem_ring \"github.com/ihciah/rust2go/mem-ring\"\n\"github.com/panjf2000/ants/v2\"\n"
    );
    let import_runtime = or_empty!(use_runtime, "\"runtime\"\n");
    let import_cgocall = or_empty!(use_cgocall, "\"github.com/ihciah/rust2go/cgocall\"\n");
    let import_asmcall = or_empty!(use_asmcall, "\"github.com/ihciah/rust2go/asmcall\"\n");
    let import_118 = or_empty!(args.go118, "\"reflect\"\n");

    let mut go_content = format!(
        "package main\n\n/*\n{importc}*/\nimport \"C\"\nimport (\n\"unsafe\"\n{import_runtime}{import_118}{import_shm}\n{import_cgocall}{import_asmcall})\n"
    );
    let levels = raw_file.convert_structs_levels().unwrap();
    r2g_traits.iter().for_each(|t| {
        go_content.push_str(&t.generate_go_interface());
        go_content.push_str(&t.generate_go_exports(&levels));
    });
    go_content.push_str(
        &raw_file
            .convert_structs_to_go(&levels, args.go118)
            .expect("Unable to generate go structs"),
    );
    if use_shm {
        go_content.push_str(RawRsFile::go_shm_ring_init());
    }
    g2r_traits.iter().for_each(|t| {
        go_content.push_str(&t.to_go(&levels));
    });
    if !args.without_main {
        go_content.push_str("func main() {}\n");
    }

    std::fs::write(&args.dst, go_content).expect("Unable to write file");

    if !args.no_fmt {
        std::process::Command::new("go")
            .arg("fmt")
            .arg(&args.dst)
            .status()
            .unwrap();
    }
}
